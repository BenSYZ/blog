<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>Introduction to precompiled headers(PCH)</title><script src=/js/if_mobile.js></script>
<script>!function(){$("pre > code").each(function(){var s,n=$(this).parent().attr("class");n==null||n===""?$(this).addClass("hljs"):(s={js:"javascript"},s[n]&&(n=s[n]),$(this).addClass(n))})}</script><link rel=stylesheet href=/css/hljs/snazzy.css><link rel=stylesheet href=/css/hljs/line-numbers.min.css><script src=/js/hljs/highlight.min.js></script>
<script src=/js/hljs/highlightjs-line-numbers.min.js></script>
<script>hljs.highlightAll()</script><script>hljs.initLineNumbersOnLoad()</script><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/footer.css><link rel=stylesheet href=/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=icon id=light-scheme-icon href=/favicons/favicon_B_Light.ico type=image/x-icon><link rel=icon id=dark-scheme-icon href=/favicons/favicon_B_Dark.ico type=image/x-icon><script src=/js/favicon.js></script></head><body><div class=container><div class=header><h1>Introduction to precompiled headers(PCH)</h1>Tue, 2024-10-08<br>本文最后修改于 Sat, 2024-10-12<hr></div><div class=middle><div id=TitleWithToc><div id=TitleOfToc>Introduction to precompiled headers(PCH)</div></div><div id=content><h2 id=introduction>Introduction</h2><p>在讲预编译头文件 PCH 的之前，我们简单回顾一下编译的流程，编译大致有以下几个步骤：</p><ol type=1><li>预处理：将源代码中的宏、头文件等展开</li><li>编译：将源代码转成汇编代码</li><li>汇编：将汇编代码转成 object 文件</li><li>链接：生成可执行文件</li></ol><p>如果有一个头文件，内容特别多，而且在好多源代码中都被引入了，那是不是会导致：每一个源代码文件在编译的时候都要展开一大段，然后在编译每一个源代码文件的时候都要重新编译这一大段，最终导致许多重复展开重复编译。那么我们是否可以将这种重复动作优化一下呢？让他只做一次，然后下次谁要用，就直接去取就完了？这就是“预编译头文件（precompiled header, PCH）” 最初的想法。</p><h2 id=what-is-pch>What is PCH?</h2><p>这是 <a href=https://zh.wikipedia.org/zh-cn/预编译头>Wikipedia 上对 PCH 的介绍</a>:</p><blockquote><p>预编译头（precompiled header）是程序设计时把头文件编译为中间格式（如目标文件），以节约在开发过程中编译器反复编译该头文件的开销。 C 语言、C++语言、Objective C 语言等都有类似的技术。</p></blockquote><p>那这个中间格式实际又是什么呢？我们在下节 “如何生成 PCH 文件” 中会来实际看看它是什么文件。</p><h2 id=如何生成-pch-文件>如何生成 PCH 文件？</h2><p>非常简单，和编译普通的源文件一样，只需对头文件做编译即可：</p><div class=sourceCode id=cb1><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb1-1><a href=#cb1-1 aria-hidden=true></a><span class=fu>gcc</span> blah.h</span></code></pre></div><p>Tips: * <code>gcc</code>/<code>g++</code> 会根据扩展名来选择默认的编译选项，对 <code>h</code> 文件，会默认使用 <code>-x c-header</code>，我们也可以强制将一个 <code>c</code> 文件用 <code>-x c-header</code> 来编译，编译成 PCH （具体请 <code>man 1 gcc</code> 搜索 <code>-x</code> 参数）</p><p>我们会发现，经过上一条命令的执行，我们得到了 <code>blah.h.gch</code> 让我们来看看这个文件是什么：</p><pre class=console><code>$ file blah.h.gch
blah.h.gch: GCC precompiled header (version 014) for C</code></pre><p>好吧，哈哈，PCH 就是 PCH，它就是单独的一个文件类型，和 <code>.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</code> 文件是不一样的。</p><h2 id=如何使用-pch-文件>如何使用 PCH 文件？</h2><p>那既然 PCH 是一个单独的文件类型，那我们要怎么使用它呢？我们知道，头文件可以用 <code>#include</code> 来引入，object 是在链接期间作为输入文件引入的。那预编译头文件呢？</p><p>这就要找 <a href=https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html>GCC 的官方文档</a> 了。文中提到，要使用 PCH 文件，你啥都不需做，就正常 <code>include</code> 原始的头文件就好，<code>gcc</code>/<code>g++</code> 在编译时，搜索头文件的时候会优先搜索同名带 <code>.gch</code> 后缀的预编译头文件。另外这个带 <code>.gch</code> 后缀的文件也可以是文件夹，里面可以放多个预编译头文件文件，<code>gcc</code>/<code>g++</code> 在编译时，会去这个目录下找任意一个可以用的预编译头文件。可以这么来理解，头文件有两种形式：文本形式和 PCH。我们来尝试使用一下预编译头文件。</p><h3 id=当-.gch-是文件时>当 <code>.gch</code> 是文件时</h3><h4 id=修改原始头文件添加-error-宏>修改原始头文件，添加 <code>#error</code> 宏</h4><p>GCC 的官方文档，给出的验证方式是 1. 编译 PCH 文件 2. 修改原始头文件，添加 <code>#error</code> 宏 3. C 源文件中 <code>include</code> 正常引入该头文件 4. 编译，查看是会报 error 还是编译通过</p><div class=sourceCode id=cb3><pre class="sourceCode c"><code class="sourceCode c"><span id=cb3-1><a href=#cb3-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true></a><span class=pp>#ifndef BLAH_H</span></span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true></a><span class=pp>#define BLAH_H</span></span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb4><pre class="sourceCode c"><code class="sourceCode c"><span id=cb4-1><a href=#cb4-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true></a>}</span></code></pre></div><pre class=console><code>$ gcc blah.h
$ echo &#39;#error &quot;PCH is not been used&quot;&#39; &gt;&gt; blah.h # blah.h 中添加 #error 宏
$ gcc blah.c</code></pre><p>我们会发现，它确实直接编译通过了，这就说明预编译头文件生效了。当然这里引入一个新的问题，我需要使用 Makefile 或是其他方式，来更新预编译头文件，来避免头文件和预编译头文件不对应。</p><h4 id=使用-gcc-的--h-参数>使用 <code>gcc</code> 的 <code>-H</code> 参数</h4><p><a href=https://stackoverflow.com/a/18593344/13033234>stackoverflow 上的这个回答</a> 介绍了一种更直接明了的方式：GCC 有一个 <code>-H</code> 参数，可以用它打印实际引用的头文件或预编译头文件。查询 GCC 的 Man pages，我们可以看到：</p><blockquote><p>-H Print the name of each header file used, in addition to other normal activities. Each name is indented to show how deep in the #include stack it is. Precompiled header files are also printed, even if they are found to be invalid; an invalid precompiled header file is printed with …x and a valid one with …! .</p></blockquote><div class=sourceCode id=cb6><pre class="sourceCode c"><code class="sourceCode c"><span id=cb6-1><a href=#cb6-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true></a><span class=pp>#ifndef BLAH_H</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true></a><span class=pp>#define BLAH_H</span></span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb7><pre class="sourceCode c"><code class="sourceCode c"><span id=cb7-1><a href=#cb7-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb7-4><a href=#cb7-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb7-5><a href=#cb7-5 aria-hidden=true></a>}</span></code></pre></div><pre class=console><code>$ gcc    blah.h
$ gcc -H blah.c
! blah.h.gch
 blah.c</code></pre><h3 id=当-.gch-是文件夹时>当 <code>.gch</code> 是文件夹时</h3><div class=sourceCode id=cb9><pre class="sourceCode c"><code class="sourceCode c"><span id=cb9-1><a href=#cb9-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true></a><span class=pp>#ifndef BLAH_H</span></span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true></a><span class=pp>#define BLAH_H</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb10><pre class="sourceCode c"><code class="sourceCode c"><span id=cb10-1><a href=#cb10-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb10-2><a href=#cb10-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb10-3><a href=#cb10-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb10-4><a href=#cb10-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb10-5><a href=#cb10-5 aria-hidden=true></a>}</span></code></pre></div><pre class=console><code>$ mkdir blah.h.gch
$ gcc    blah.h -o  blah.h.gch/c
$ gcc -H blah.c
! blah.h.gch/c
 blah.c</code></pre><p>也是可以正常使用的。</p><h3 id=在-qt-中使用-pch>在 Qt 中使用 PCH</h3><p><a href=https://doc.qt.io/qt-6/qmake-precompiledheaders.html>Qt</a> 中只需在 <code>.pro</code> 中加入以下两行，并在 <code>stable.h</code> 中放入你想预编译的头文件，Qt 对单个项目目前只支持一个全局的预编译头文件。</p><div class=sourceCode id=cb12><pre class="sourceCode pro"><code class="sourceCode prolog"><span id=cb12-1><a href=#cb12-1 aria-hidden=true></a><span class=dt>CONFIG</span>   += precompile_header</span>
<span id=cb12-2><a href=#cb12-2 aria-hidden=true></a><span class=dt>PRECOMPILED_HEADER</span> <span class=kw>=</span> stable<span class=kw>.</span>h</span></code></pre></div><p>然后 <code>qmake</code> 会自动生成对应的 <code>Makefile</code>，完成以下几件事： 1. 递归地找到所有依赖的头文件，将它们放在 PCH 的 prerequisite，来做到当头文件更新时，PCH 会更新。 2. 在所有 <code>.o</code> 的 target 中通过 <code>-include</code> 的方式强制引入 PCH 文件 3. 将 PCH 文件，作为所有 <code>.o</code> 的 target 的 prerequisite</p><ul><li>Tips:<ul><li>需要注意的是，通过上面几条 <code>Makefile</code> 的规则，如果任意一个构成 PCH 的头文件变更，都会导致 PCH 更新，从而导致所有 .o 重编，反而使增量编译时间变长。这也是 Qt 问什么称这个文件为 <code>stable.h</code> 的原因</li></ul></li></ul><h2 id=预编译头文件失效invalid>预编译头文件失效（invalid）</h2><p>我们前面说到，“会去这个目录下找任意一个可以用的预编译头文件”，那什么时可用的，什么是不可用的呢？</p><h3 id=gccg-编译器不同>GCC/G++ 编译器不同</h3><p>GCC 编译时，不能使用 G++ 编译出来的预编译头文件，反之亦然。例如：</p><div class=sourceCode id=cb13><pre class="sourceCode c"><code class="sourceCode c"><span id=cb13-1><a href=#cb13-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb13-2><a href=#cb13-2 aria-hidden=true></a><span class=pp>#ifndef BLAH_H</span></span>
<span id=cb13-3><a href=#cb13-3 aria-hidden=true></a><span class=pp>#define BLAH_H</span></span>
<span id=cb13-4><a href=#cb13-4 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb14><pre class="sourceCode c"><code class="sourceCode c"><span id=cb14-1><a href=#cb14-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb14-2><a href=#cb14-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb14-3><a href=#cb14-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb14-4><a href=#cb14-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb14-5><a href=#cb14-5 aria-hidden=true></a>}</span></code></pre></div><pre class=console><code>$ g++ blah.h -o blah.h.gch
$ gcc -H blah.c
x blah.h.gch
. blah.h</code></pre><h3 id=头文件中的宏例如-ifdef引入分支>头文件中的宏（例如 <code>#ifdef</code>）引入分支</h3><p>头文件中有宏（例如 <code>#ifdef</code>）引入分支，编译 PCH 时的分支和使用 PCH 时的分支不同</p><div class=sourceCode id=cb16><pre class="sourceCode c"><code class="sourceCode c"><span id=cb16-1><a href=#cb16-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb16-2><a href=#cb16-2 aria-hidden=true></a><span class=pp>#ifndef BLAH_H</span></span>
<span id=cb16-3><a href=#cb16-3 aria-hidden=true></a><span class=pp>#define BLAH_H</span></span>
<span id=cb16-4><a href=#cb16-4 aria-hidden=true></a></span>
<span id=cb16-5><a href=#cb16-5 aria-hidden=true></a><span class=pp>#ifdef blah_1</span></span>
<span id=cb16-6><a href=#cb16-6 aria-hidden=true></a><span class=pp>#define blah 1</span></span>
<span id=cb16-7><a href=#cb16-7 aria-hidden=true></a><span class=pp>#else</span></span>
<span id=cb16-8><a href=#cb16-8 aria-hidden=true></a><span class=pp>#define blah 2</span></span>
<span id=cb16-9><a href=#cb16-9 aria-hidden=true></a><span class=pp>#endif</span></span>
<span id=cb16-10><a href=#cb16-10 aria-hidden=true></a></span>
<span id=cb16-11><a href=#cb16-11 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb17><pre class="sourceCode c"><code class="sourceCode c"><span id=cb17-1><a href=#cb17-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb17-2><a href=#cb17-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb17-3><a href=#cb17-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb17-4><a href=#cb17-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb17-5><a href=#cb17-5 aria-hidden=true></a>}</span></code></pre></div><pre class=console><code>$ gcc -D blah_1 blah.h -o blah.h.gch

$ gcc -H blah.c
x blah.h.gch
. blah.h</code></pre><h2 id=解决失效问题>解决失效问题</h2><p>当然最直接的方式是该怎么样怎么样，GCC 编译就用 GCC 编译 PCH，编译 object 时的分支走哪个编译 PCH 时就走哪个。</p><p>但有一个问题：每换一个编译器，或每换一个宏（例如编译配置宏）都要重新编译预编译头文件，又或者需要自己拷来拷去。十分麻烦，有什么方式可以避免手动拷吗？把 <code>.gch</code> 改成文件夹，往里面放各种有效的头文件，我们上面说过：GCC 会去这个目录下找任意一个可以用的预编译头文件。也就是说，你可以在这个目录下放多版不同情况下的预编译头文件，让 GCC 自动找寻合适的预编译头文件，</p><h3 id=gccg-编译器不同-1>GCC/G++ 编译器不同</h3><p>我们可以同时放 GCC/G++ 的预编译头文件，让 GCC/G++ 自己选择</p><pre class=console><code>$ mkdir           blah.h.gch
$ gcc   blah.h -o blah.h.gch/c
$ g++   blah.h -o blah.h.gch/c++

$ gcc -H blah.c
! blah.h.gch/c
blah.c
$ g++ -H blah.c
x blah.h.gch/c
! blah.h.gch/c++
 blah.c</code></pre><h3 id=头文件中有宏例如-ifdef引入分支>头文件中有宏（例如 <code>#ifdef</code>）引入分支</h3><div class=sourceCode id=cb20><pre class="sourceCode c"><code class="sourceCode c"><span id=cb20-1><a href=#cb20-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb20-2><a href=#cb20-2 aria-hidden=true></a><span class=pp>#ifdef blah_1</span></span>
<span id=cb20-3><a href=#cb20-3 aria-hidden=true></a><span class=pp>#define blah 1</span></span>
<span id=cb20-4><a href=#cb20-4 aria-hidden=true></a><span class=pp>#else</span></span>
<span id=cb20-5><a href=#cb20-5 aria-hidden=true></a><span class=pp>#define blah 2</span></span>
<span id=cb20-6><a href=#cb20-6 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb21><pre class="sourceCode c"><code class="sourceCode c"><span id=cb21-1><a href=#cb21-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb21-2><a href=#cb21-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb21-3><a href=#cb21-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb21-4><a href=#cb21-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb21-5><a href=#cb21-5 aria-hidden=true></a>}</span></code></pre></div><pre class=console><code>$ gcc           blah.h -o blah.h.gch/c1
$ gcc -D blah_1 blah.h -o blah.h.gch/c2

$ gcc -H blah.c
! blah.h.gch/c1
 blah.c

$ gcc -D blah_1 -H blah.c
x blah.h.gch/c1
! blah.h.gch/c2
 blah.c</code></pre><h2 id=常见的错误>常见的错误</h2><p>除了上述说的 <code>gcc -H</code> 和 <code>#error</code>，我们也可以使用 <code>-Winvalid-pch</code> 来让 GCC 吐出 PCH 失效问题的详细信息。 ### <code>blah.h.gch: not for GNU C17</code> 即上面说的 GCC 不能使用 G++ 编译的 PCH。</p><h3 id=blah.h.gch-not-used-because-xxx-not-defined><code>blah.h.gch: not used because xxx not defined</code></h3><p>即上面说的编译 PCH 和使用 PCH 时宏分支不同。</p><h3 id=cc1plus-error-one-or-more-pch-files-were-found-but-they-were-invalid><code>cc1plus: error: one or more PCH files were found, but they were invalid</code></h3><p>这种情况出现在使用 <code>-include</code> 强制引入头文件，当这个头文件只有 PCH 的形式而没有文本形式时，便会报这个错，和这个错在一起的还有</p><pre><code>&lt;command-line&gt;: fatal error: test_pch: No such file or directory</code></pre><div class=sourceCode id=cb24><pre class="sourceCode c"><code class="sourceCode c"><span id=cb24-1><a href=#cb24-1 aria-hidden=true></a><span class=co>// blah.h</span></span>
<span id=cb24-2><a href=#cb24-2 aria-hidden=true></a><span class=pp>#ifndef BLAH_H</span></span>
<span id=cb24-3><a href=#cb24-3 aria-hidden=true></a><span class=pp>#define BLAH_H</span></span>
<span id=cb24-4><a href=#cb24-4 aria-hidden=true></a></span>
<span id=cb24-5><a href=#cb24-5 aria-hidden=true></a><span class=pp>#define blah 1</span></span>
<span id=cb24-6><a href=#cb24-6 aria-hidden=true></a></span>
<span id=cb24-7><a href=#cb24-7 aria-hidden=true></a><span class=pp>#endif</span></span></code></pre></div><div class=sourceCode id=cb25><pre class="sourceCode c"><code class="sourceCode c"><span id=cb25-1><a href=#cb25-1 aria-hidden=true></a><span class=co>// blah.c</span></span>
<span id=cb25-2><a href=#cb25-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&quot;blah.h&quot;</span></span>
<span id=cb25-3><a href=#cb25-3 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb25-4><a href=#cb25-4 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb25-5><a href=#cb25-5 aria-hidden=true></a>}</span></code></pre></div><pre class=make><code>pch_fake_header = test_pch
pch_dir         = $(pch_fake_header).gch

old_external_macro = old
new_external_macro = new

target = main

help:
    printf &quot;Use the two commands to test the two cases:\nmake demo_1\nmake demo_2\n&quot;

demo_1: clean
    echo &quot;macro changes&quot;
    mkdir -p $(pch_dir)
    gcc -D external_macro=\&quot;$(old_external_macro)\&quot;                             -o $(pch_dir)/c blah.h
    gcc -D external_macro=\&quot;$(new_external_macro)\&quot; -include $(pch_fake_header) -o $(target)    main.c

demo_2: clean
    echo &quot;gch generated with gcc&quot;
    mkdir -p $(pch_dir)
    g++ -D external_macro=\&quot;$(old_external_macro)\&quot;                             -o $(pch_dir)/c blah.h
    gcc -D external_macro=\&quot;$(new_external_macro)\&quot; -include $(pch_fake_header) -o $(target)    main.c



main: pch
    gcc -include $(pch_fake_header) -D external_macro=\&quot;$(new_external_macro)\&quot; -o $(target) main.c

pch:
    mkdir -p $(pch_dir)
    gcc -D external_macro=\&quot;$(old_external_macro)\&quot; -o $(pch_dir)/c blah.h

clean:
    [ -e $(pch_dir) ] &amp;&amp; rm -r $(pch_dir) || true
    rm -f $(target)</code></pre><h3 id=error-stray-xxx-in-program><code>error: stray xxx in program</code></h3><p>这种情况一样出现在使用 <code>-include</code> 强制引入头文件的情况，当这个头文件只有 PCH 的形式而没有文本形式时，但上一次编译的 ELF 文件生成了，生成的名称正好是强制引入的头文件的头文件，便会报这个错，原因是，这次直接 include 了二进制文件。这种情况在 Qt 中出现过，Qt 配置 PCH 后，会将 PCH 文件放在 <code>TARGET.gch</code> 文件夹中，而该文件夹的目录和 <code>TARGET</code> 同级。</p><h3 id=pch-有效但是并未使用>PCH 有效但是并未使用</h3><p>从 GCC 文档中看到，如果某个头文件要使用 PCH 的形式，必须在整个文件中第一行 C 代码前。而最常见的 <code>stdio.h</code> 中有 C 代码，所以，如果我们将自己的头文件放在 <code>stdio.h</code> 之后，GCC 是不会使用 PCH 的。</p></div><div id=Rsidebar><div id=Avatar><img alt=avatar src=/avatar.jpg></div><ul><li><a href=/about>About Me</a></li><li><a href=/donate>Donate Me</a></li><li><a href=/>Ben's Blog</a></li></ul>除非注明，本博客所有文章皆为原创。<br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</div></div><div class=footer><div id=tags><a href=https://bensyz.github.io/blog/tags><i class="fas fa-tags"></i></a>
Keywords:<ul><li><a href=https://bensyz.github.io/blog/tags/PCH>PCH</a></li><li><a href=https://bensyz.github.io/blog/tags/GCC>GCC</a></li><li><a href=https://bensyz.github.io/blog/tags/compile>compile</a></li></ul></div><footer><hr><a href=/>Ben's Blog</a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33028102001039"><img alt=public_safety_record src=/icons/public_safety_icon.png>浙公网安备 33028102001039号</a>
<a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备2021032097号-1</a></footer></div></div></body></html>