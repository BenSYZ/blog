<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>file descriptor and fd redirection in bash</title><script src=/js/if_mobile.js></script>
<script>!function(){$("pre > code").each(function(){var s,n=$(this).parent().attr("class");n==null||n===""?$(this).addClass("hljs"):(s={js:"javascript"},s[n]&&(n=s[n]),$(this).addClass(n))})}</script><link rel=stylesheet href=/css/hljs/snazzy.css><link rel=stylesheet href=/css/hljs/line-numbers.min.css><script src=/js/hljs/highlight.min.js></script>
<script src=/js/hljs/highlightjs-line-numbers.min.js></script>
<script>hljs.highlightAll()</script><script>hljs.initLineNumbersOnLoad()</script><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/footer.css><link rel=stylesheet href=/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=icon id=light-scheme-icon href=/favicons/favicon_B_Light.ico type=image/x-icon><link rel=icon id=dark-scheme-icon href=/favicons/favicon_B_Dark.ico type=image/x-icon><script src=/js/favicon.js></script></head><body><div class=container><div class=header><h1>file descriptor and fd redirection in bash</h1>Fri, 2025-07-18<hr></div><div class=middle><div id=TitleWithToc><div id=TitleOfToc>file descriptor and fd redirection in bash</div></div><div id=content><h2 id=文件描述符>文件描述符</h2><p>文件描述符（file descriptor，简称 fd）在 Linux 中表示文件的句柄（file handle）但它到底是个啥呢？我们知道在 Linux 中，我们可以用 <code>open</code> 函数打开一个文件，返回的是 <code>int</code>，所以 fd 就是一个整型数组。我们可以在 <code>/proc/&lt;pid>/fd</code> 中看到某个进程当前打开的文件。如果是磁盘上的文件，那就是一个 symbolic link 指向那个文件。当然还有其他管道文件。</p><p>那这个整型变量 fd 到底是什么呢？我们会发现 fd 的来源 <code>open</code> 其实不是普通的函数，它其实是一个系统调用，是 Linux 内核提供给应用程序的 API。在内核中 fd 这个整型是指该进程（<code>struct task</code>）打开的文件列表（（<code>struct task -> struct files_struct -> struct file *</code>））数组的下标。应用程序将来要操作这个文件只需要将这个 <code>int</code> 丢给操作系统，操作系统就会代替程序去读取写入实际的文件。</p><h2 id=标准输入标准输出和错误输出>标准输入、标准输出和错误输出</h2><p>在 Linux 中有三个较为特殊的文件描述符，它们是</p><ul><li>标准输入（stdin）：<code>fd=0</code></li><li>标准输出（stdout）：<code>fd=1</code></li><li>标准错误输出（stderr）：<code>fd=2</code></li></ul><p>我们在用 <code>fprintf</code> 的时候会用到他们，因为对应用程序来说，往屏幕上输出东西，也非它所能做的，也需要操作系统这个代理来实现。因为他们太基础了，所以默认这三个是开给所有的进程的。</p><h2 id=bash-中的-fd>bash 中的 fd</h2><p>man bash 中 REDIRECTION 节有详细的介绍</p><ul><li>Tips: 在下面的例子中，我们可以用 <code>echo $$</code> 得到当前进程的 PID，在合适的地方 <code>sleep</code>，然后外部去访问 <code>/proc/&lt;pid>/fd</code> 查看当前 <code>fd</code> 的情况。</li></ul><h3 id=fd-的表示>fd 的表示</h3><ul><li>输入：<code>[fd]&lt;</code></li><li>输出：<code>[fd]></code></li></ul><h3 id=fd-的新建>fd 的新建</h3><h4 id=输入>输入</h4><p><code>[fd]&lt; input_file</code></p><div class=sourceCode id=cb1><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb1-1><a href=#cb1-1 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&lt;</span> /etc/os-release</span>
<span id=cb1-2><a href=#cb1-2 aria-hidden=true></a><span class=kw>while</span> <span class=bu>read</span> -r -u 3 <span class=va>line</span>;<span class=kw>do</span></span>
<span id=cb1-3><a href=#cb1-3 aria-hidden=true></a>    <span class=bu>echo</span> <span class=st>&quot;</span><span class=va>$line</span><span class=st>&quot;</span></span>
<span id=cb1-4><a href=#cb1-4 aria-hidden=true></a><span class=kw>done</span></span>
<span id=cb1-5><a href=#cb1-5 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&lt;</span><span class=kw>&amp;</span><span class=ex>-</span></span></code></pre></div><h4 id=输出>输出</h4><p><code>[fd]> output_file</code></p><div class=sourceCode id=cb2><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb2-1><a href=#cb2-1 aria-hidden=true></a><span class=bu>echo</span> stdout <span class=op>1&gt;</span> ./stdout.txt</span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true></a><span class=bu>echo</span> stdout <span class=op>2&gt;</span> ./stderr.txt</span></code></pre></div><h3 id=fd-的复制>fd 的复制</h3><p>由于大部分的程序，输入输出只有三个标准输入，标准输出，标准错误输出，那我如何将标准输出重定向到任意一个 fd 上呢？</p><p>取出 fd 中当前真正的输出对象(并将其赋值)</p><p><code>bash</code> 中用 <code>&amp;fd</code> 来表示真正的输入输出通道，这个 <code>&</code> 大概是指 fd 1 2 3 只是 alias，我要取出 alias 原本的值，也就是真正的输入输出通道，然后传递给其他 fd alias。（这么看来 bash 的 fd 和变量的 fd 不对应，& 符号太反人类了。。。<del>不应是 <code>*1</code> <code>*2</code> 吗</del>）</p><h4 id=输入-1>输入</h4><p><code>[fd_dst]&lt;&amp;fd_src</code></p><div class=sourceCode id=cb3><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb3-1><a href=#cb3-1 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&lt;</span> /etc/os-release</span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true></a><span class=fu>cat</span> <span class=op>0&lt;&amp;3</span></span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&lt;</span><span class=kw>&amp;</span><span class=ex>-</span></span></code></pre></div><p><code>cat</code> 只接收标准输入，那么我可以用 <code>0&lt;&amp;3</code> 将 <code>fd3</code> 实质的输入通道传递给 <code>fd0</code>，接到 <code>fd0</code> 上。</p><h4 id=输出-1>输出</h4><p><code>[fd_dst]>&amp;fd_src</code></p><div class=sourceCode id=cb4><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb4-1><a href=#cb4-1 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&gt;</span> ./fd3.txt</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true></a><span class=bu>echo</span> stdout <span class=op>1&gt;&amp;3</span></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&gt;</span><span class=kw>&amp;</span><span class=ex>-</span></span></code></pre></div><p><code>echo</code> 输出到标准输出，所以我可以用 <code>1>&amp;3</code> 将 <code>fd3</code> 实质的输出通道传递给 <code>fd1</code>，接到 <code>fd1</code> 的后面</p><h3 id=fd-的关闭>fd 的关闭</h3><h4 id=输入-2>输入</h4><p><code>[fd]&lt;&-</code></p><p>我们已经看到过好多次 <code>[fd]&lt;&-</code> 它代表关闭这个 <code>fd</code>。</p><h4 id=输出-2>输出</h4><p><code>[fd]>&-</code></p><p>和输入一样 <code>[fd]>&-</code> 它代表关闭这个 <code>fd</code>。</p><h3 id=fd-的移动>fd 的移动</h3><p>相较于 复制，就是在后面加一个 <code>-</code> #### 输入 <code>[fd_dst]&&lt;fd_src-</code></p><h4 id=输出-3>输出</h4><p><code>[fd_dst]&>fd_src-</code></p><p>这在交换 stdout stderr 时很有用，无需反复开关</p><div class=sourceCode id=cb5><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb5-1><a href=#cb5-1 aria-hidden=true></a><span class=bu>exec</span> <span class=op>3&gt;&amp;1-</span>  # stdout(fd1) 接到 <span class=ex>fd3</span> 上</span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true></a><span class=bu>exec</span> <span class=op>1&gt;&amp;2-</span>  # stderr(fd2) 接到 <span class=ex>fd1</span> 上</span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true></a><span class=bu>exec</span> <span class=op>2&gt;&amp;3-</span>  # stderr(fd3) 接到 <span class=ex>fd2</span> 上</span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true></a></span>
<span id=cb5-5><a href=#cb5-5 aria-hidden=true></a><span class=kw>{</span></span>
<span id=cb5-6><a href=#cb5-6 aria-hidden=true></a>    <span class=bu>echo</span> stdout</span>
<span id=cb5-7><a href=#cb5-7 aria-hidden=true></a>    <span class=bu>echo</span> stderr <span class=op>&gt;&amp;2</span></span>
<span id=cb5-8><a href=#cb5-8 aria-hidden=true></a><span class=kw>}</span> <span class=op>&gt;</span> <span class=ex>/dev/null</span></span></code></pre></div><h3 id=tips>Tips</h3><h5 id=单行的重定向>单行的重定向</h5><p>上文中我们用 exec 去新建、修改 fd，我们也可以在单行中新建和修改 fd。注意： <strong>Bash 中单行的重定向讲究顺序，从左到右执行</strong></p><div class=sourceCode id=cb6><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb6-1><a href=#cb6-1 aria-hidden=true></a><span class=bu>echo</span> stdout <span class=op>3&gt;</span> ./fd3.txt <span class=op>1&gt;&amp;3</span></span></code></pre></div><p>先定义一个 <code>fd3</code>，在将 echo 的 <code>fd1</code> 重定向到 <code>fd3</code>，倘若是下面这样，第一步 <code>1>&amp;3</code> 时 <code>&amp;3</code> 还没有定义，就会报 <code>3: Bad file descriptor</code></p><div class=sourceCode id=cb7><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb7-1><a href=#cb7-1 aria-hidden=true></a><span class=bu>echo</span> stdout <span class=op>1&gt;&amp;3</span> <span class=op>3&gt;</span> ./fd3.txt</span></code></pre></div><p>所以常见的将所有的输入输出全输出到 <code>/dev/null</code> 是需要 <code>>/dev/null 2>&amp;1</code> 而不能 <code>2>&amp;1 >/dev/null</code>，后者先将 <code>fd2</code> 接到 <code>fd1</code> 此时也就是标准输出的通道，再将标准输出接到 <code>/dev/null</code></p><div class=sourceCode id=cb8><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb8-1><a href=#cb8-1 aria-hidden=true></a><span class=kw>{</span></span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true></a>    <span class=bu>echo</span> stdout</span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true></a>    <span class=bu>echo</span> stderr <span class=op>&gt;&amp;2</span> <span class=co># 重定向输出到 stdout</span></span>
<span id=cb8-4><a href=#cb8-4 aria-hidden=true></a><span class=kw>}</span> <span class=op>&gt;</span><span class=ex>/dev/null</span> <span class=op>2&gt;&amp;1</span></span></code></pre></div><h5 id=为避免冲突让-bash-分配-fd>为避免冲突让 bash 分配 fd</h5><div class=sourceCode id=cb9><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb9-1><a href=#cb9-1 aria-hidden=true></a><span class=bu>exec</span> <span class=dt>{fd}</span><span class=op>&lt;</span> /etc/os-release</span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true></a><span class=kw>while</span> <span class=bu>read</span> -r -u <span class=st>&quot;</span><span class=va>${fd}</span><span class=st>&quot;</span> <span class=va>line</span>;<span class=kw>do</span></span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true></a>    <span class=bu>echo</span> <span class=st>&quot;</span><span class=va>$line</span><span class=st>&quot;</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true></a><span class=kw>done</span></span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true></a><span class=bu>exec</span> <span class=dt>{fd}</span><span class=op>&lt;</span><span class=kw>&amp;</span><span class=ex>-</span></span></code></pre></div><h4 id=其他各种箭头>其他各种箭头</h4><h5 id=output-append><code>>></code>: Output Append</h5><p><code>>></code> 很常见，append 到文件上</p><h5 id=here-documents><code>&lt;&lt;</code>: Here Documents</h5><p>输入没有 append 的概念，bash 就将这个当作 Here Documents，最常见的就是生成一个 shell 脚本时可以用，免得一行一行 echo</p><div class=sourceCode id=cb10><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb10-1><a href=#cb10-1 aria-hidden=true></a><span class=fu>cat</span> <span class=op>&lt;&lt; EOF</span> <span class=op>&gt;</span> <span class=ex>here_doc.sh</span></span>
<span id=cb10-2><a href=#cb10-2 aria-hidden=true></a>#!/bin/bash</span>
<span id=cb10-3><a href=#cb10-3 aria-hidden=true></a>echo &quot;arg1=<span class=dt>\$</span>1&quot;</span>
<span id=cb10-4><a href=#cb10-4 aria-hidden=true></a>echo test text</span>
<span id=cb10-5><a href=#cb10-5 aria-hidden=true></a>EOF</span></code></pre></div><p>还可以输入给 bc</p><ul><li>这里的 <code>EOF</code> 可以是任意字符串</li><li>here documents 会展开变量，如果希望在生成的脚本中展开时这里需要 <code>\</code>，或者将 <code>EOF</code> 用单引号包起来，可以避免转义 <code>$1</code> 等变量</li></ul><div class=sourceCode id=cb11><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb11-1><a href=#cb11-1 aria-hidden=true></a><span class=fu>cat</span> <span class=op>&lt;&lt; &#39;EOF&#39;</span> <span class=op>&gt;</span> <span class=ex>here_doc.sh</span></span>
<span id=cb11-2><a href=#cb11-2 aria-hidden=true></a>#!/bin/bash</span>
<span id=cb11-3><a href=#cb11-3 aria-hidden=true></a>echo &quot;arg1=$1&quot;</span>
<span id=cb11-4><a href=#cb11-4 aria-hidden=true></a>echo test text</span>
<span id=cb11-5><a href=#cb11-5 aria-hidden=true></a>EOF</span></code></pre></div><h5 id=here-string><code>&lt;&lt;&lt;</code>: Here String</h5><p>上文中的输入输出的对象都是文件，here string 可以将后面的 string 直接输入到 stdin</p><div class=sourceCode id=cb12><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb12-1><a href=#cb12-1 aria-hidden=true></a><span class=fu>cat</span> <span class=op>&lt;&lt;&lt;</span> <span class=st>&quot;here string&quot;</span></span>
<span id=cb12-2><a href=#cb12-2 aria-hidden=true></a><span class=fu>wc</span> <span class=op>&lt;&lt;&lt;</span> <span class=st>&quot;here string&quot;</span></span></code></pre></div><h5 id=cmd-和-cmd-process-substitution><code>&lt;(cmd)</code> 和 <code>>(cmd)</code>: Process Substitution</h5><h6 id=输入-cmd>输入 <code>&lt;(cmd)</code></h6><p>如果想要将命令的结果输入到 stdin，当然最简单的是管道，但管道有一个限制，管道后面的进程在 sub-shell 里，里面变量的修改影响不到当前 shell。此时 <code>&lt;(cmd)</code> 就有用了。Process Substitution 本质也是管道或者说也是 fd，只是将 <code>&lt;(cmd)</code> 的输出做一个 fd，然后这个 fd 可以用 stdin <code>&lt;</code> 来接收</p><div class=sourceCode id=cb13><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb13-1><a href=#cb13-1 aria-hidden=true></a><span class=fu>ls</span> -la <span class=op>&lt;(</span><span class=bu>echo</span> bar<span class=op>)</span></span></code></pre></div><div class=sourceCode id=cb14><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb14-1><a href=#cb14-1 aria-hidden=true></a><span class=va>nic_8168=()</span></span>
<span id=cb14-2><a href=#cb14-2 aria-hidden=true></a><span class=kw>while</span> <span class=bu>read</span> -r <span class=va>nic</span>;<span class=kw>do</span></span>
<span id=cb14-3><a href=#cb14-3 aria-hidden=true></a>    <span class=va>nic_8168+=(</span><span class=st>&quot;</span><span class=va>$nic</span><span class=st>&quot;</span><span class=va>)</span></span>
<span id=cb14-4><a href=#cb14-4 aria-hidden=true></a><span class=kw>done</span> <span class=op>&lt;</span> <span class=op>&lt;(</span> <span class=fu>find</span> /sys/bus/pci/drivers/r816<span class=dt>{8,9}</span>/*:*:*/net/ -maxdepth 1 -mindepth 1 -exec basename {} <span class=dt>\;</span> <span class=op>2&gt;</span><span class=ex>/dev/null</span><span class=op>)</span></span></code></pre></div><h6 id=输出-cmd>输出 <code>>(cmd)</code></h6><p>如果想要将命令的结果输入给另一个程序，最简单的还是是管道，但管道只能接 stdout，当然你也可以像上面一样交换 fd1 fd2 和 stdout stderr 的对应。但更简单的方式是 <code>>(cmd)</code></p><div class=sourceCode id=cb15><pre class="sourceCode sh"><code class="sourceCode bash"><span id=cb15-1><a href=#cb15-1 aria-hidden=true></a><span class=kw>{</span></span>
<span id=cb15-2><a href=#cb15-2 aria-hidden=true></a>    <span class=bu>echo</span> stdout</span>
<span id=cb15-3><a href=#cb15-3 aria-hidden=true></a>    <span class=bu>echo</span> stderr1 <span class=op>&gt;&amp;2</span></span>
<span id=cb15-4><a href=#cb15-4 aria-hidden=true></a>    <span class=bu>echo</span> stderr2 <span class=op>&gt;&amp;2</span></span>
<span id=cb15-5><a href=#cb15-5 aria-hidden=true></a><span class=kw>}</span> <span class=op>2&gt;</span> <span class=op>&gt;(</span> <span class=fu>grep</span> -c stderr <span class=op>&gt;&amp;2)</span></span></code></pre></div></div><div id=Rsidebar><div id=Avatar><img alt=avatar src=/avatar.jpg></div><ul><li><a href=/about>About Me</a></li><li><a href=/donate>Donate Me</a></li><li><a href=/>Ben's Blog</a></li></ul>除非注明，本博客所有文章皆为原创。<br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</div></div><div class=footer><div id=tags><a href=https://bensyz.github.io/blog/tags><i class="fas fa-tags"></i></a>
Keywords:<ul><li><a href=https://bensyz.github.io/blog/tags/file-descriptor>file descriptor</a></li><li><a href=https://bensyz.github.io/blog/tags/Linux>Linux</a></li><li><a href=https://bensyz.github.io/blog/tags/shell>shell</a></li><li><a href=https://bensyz.github.io/blog/tags/bash>bash</a></li></ul></div><footer><hr><a href=/>Ben's Blog</a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33028102001039"><img alt=public_safety_record src=/icons/public_safety_icon.png>浙公网安备 33028102001039号</a>
<a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备2021032097号-1</a></footer></div></div></body></html>