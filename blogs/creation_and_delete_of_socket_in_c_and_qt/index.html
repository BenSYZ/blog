<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>C 和 Qt 中 socket 的创建和删除</title><script src=/js/if_mobile.js></script>
<script>!function(){$("pre > code").each(function(){var s,n=$(this).parent().attr("class");n==null||n===""?$(this).addClass("hljs"):(s={js:"javascript"},s[n]&&(n=s[n]),$(this).addClass(n))})}</script><link rel=stylesheet href=/css/hljs/snazzy.css><link rel=stylesheet href=/css/hljs/line-numbers.min.css><script src=/js/hljs/highlight.min.js></script>
<script src=/js/hljs/highlightjs-line-numbers.min.js></script>
<script>hljs.highlightAll()</script><script>hljs.initLineNumbersOnLoad()</script><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/footer.css><link rel=stylesheet href=/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=icon id=light-scheme-icon href=/favicons/favicon_B_Light.ico type=image/x-icon><link rel=icon id=dark-scheme-icon href=/favicons/favicon_B_Dark.ico type=image/x-icon><script src=/js/favicon.js></script></head><body><div class=container><div class=header><h1>C 和 Qt 中 socket 的创建和删除</h1>Thu, 2022-04-14<hr></div><div class=middle><div id=TitleWithToc><div id=TitleOfToc>C 和 Qt 中 socket 的创建和删除</div></div><div id=content><h1 id=c-和-qt-中-socket-的创建和删除>C 和 Qt 中 socket 的创建和删除</h1><p>[toc]</p><h2 id=c>C</h2><p><a href=https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/>example code</a></p><h3 id=客户端>客户端</h3><p>客户端相对来说比较简单：创建，然后 connect</p><div class=sourceCode id=cb1><pre class="sourceCode c"><code class="sourceCode c"><span id=cb1-1><a href=#cb1-1 aria-hidden=true></a>connect(sockfd, (SA*)&amp;servaddr, <span class=kw>sizeof</span>(servaddr));</span></code></pre></div><h3 id=服务端>服务端</h3><p>服务端相对来说会复杂一些</p><div class=sourceCode id=cb2><pre class="sourceCode c"><code class="sourceCode c"><span id=cb2-1><a href=#cb2-1 aria-hidden=true></a>bind(sockfd, (SA*)&amp;servaddr, <span class=kw>sizeof</span>(servaddr));</span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true></a>listen(sockfd, <span class=dv>5</span>);</span>
<span id=cb2-3><a href=#cb2-3 aria-hidden=true></a>connfd = accept(sockfd, (SA*)&amp;cli, &amp;len);</span></code></pre></div><p>先新建一个 socket 然后这个socket 来做监听，用 accept 取到和客户端连接的服务端的socket</p><p>从 <code>man 2 accept</code> 可以知道 accept 做了这些事：</p><ol type=1><li>从这个监听的 socket 中取出第一个连接请求</li><li>创建一个新的连接着的socket，</li><li>返回一个指向这个 socket 的文件描述符</li></ol><p>这里返回的 socket 是一个变量，也就是说它是在栈里的，当退出函数的时候，这个 socket 会自动释放。</p><h4 id=文件描述符>文件描述符：</h4><p>文件描述符号是 int。</p><p>在 socket 断连再重连的时候我们看到对于一个新的 socket，他的文件描述符没变，那 accept 建立的socket 还是原来的吗？答案是否定的。</p><p>文件描述符在系统中在这里 <code>/proc/&lt;PID>/fd/&lt;fdNum></code> 虽然新的socket 的描述符还是 21，但它的软连接对象已经变了。</p><pre><code>/proc/30475/fd/21 -&gt; socket:[31166317]
/proc/30475/fd/21 -&gt; socket:[31206486]

cat /proc/net/tcp |grep 31206486</code></pre><h2 id=qt>Qt</h2><p>Qt 就结构上也差不多，只不过它把服务端的监听的 socket 抽象成了 <code>QTcpServer</code>，但有一个区别就是 accept 在 Qt 中的对应是 <code>QTcpSocket *QTcpServer::nextPendingConnection()</code>，注意这里返回的是一个指针也就是说它现在不再栈中了，而是在堆中，那它是在什么时候建的呢，我是否可以删除它？那就去翻源码咯(doge)</p><div class=sourceCode id=cb4><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb4-1><a href=#cb4-1 aria-hidden=true></a><span class=ex>QTcpSocket</span> *<span class=ex>QTcpServer::</span>nextPendingConnection()</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true></a>    <span class=cf>return</span> d-&gt;pendingConnections.takeFirst();</span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true></a></span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true></a><span class=dt>void</span> <span class=ex>QTcpServer::</span>addPendingConnection(<span class=ex>QTcpSocket</span>* socket)</span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true></a>    d_func()-&gt;pendingConnections.append(socket);</span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true></a></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true></a><span class=dt>void</span> <span class=ex>QTcpServer::</span>incomingConnection(qintptr socketDescriptor)</span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true></a>    <span class=ex>QTcpSocket</span> *socket = <span class=kw>new</span> <span class=ex>QTcpSocket</span>(<span class=kw>this</span>);</span>
<span id=cb4-9><a href=#cb4-9 aria-hidden=true></a>    socket-&gt;setSocketDescriptor(socketDescriptor);</span>
<span id=cb4-10><a href=#cb4-10 aria-hidden=true></a>    addPendingConnection(socket);</span>
<span id=cb4-11><a href=#cb4-11 aria-hidden=true></a></span>
<span id=cb4-12><a href=#cb4-12 aria-hidden=true></a><span class=dt>void</span> QTcpServerPrivate::readNotification()</span>
<span id=cb4-13><a href=#cb4-13 aria-hidden=true></a>    <span class=dt>int</span> descriptor = socketEngine-&gt;accept();</span>
<span id=cb4-14><a href=#cb4-14 aria-hidden=true></a>    q-&gt;incomingConnection(descriptor);</span></code></pre></div><p>我们可以看到 <code>pendingConnections</code> 里面的 <code>socket</code> 是在 <code>incommingConnection</code> 那里 <code>new</code> 的</p><p>那我们什么时候去 delete 呢，查阅 <a href=https://doc.qt.io/qt-5/implicit-sharing.html>隐式共享</a>，QAbstractsocket 不在其中，所以需要对它进行手动释放。 在 <a href=https://stackoverflow.com/questions/28820450/how-to-safely-delete-a-qtqtcpsocket>stack overflow 的这个回答</a> 中就说了，在 QTcpServer 删除的时候会把所有的socket 都释放掉，也就是 Qt 释放时的树状结构。但为了追求高效率，我们可以手动去释放掉。根据 Qt 的 <a href=https://doc.qt.io/archives/qt-4.8/objecttrees.html>手册</a>: When any QObject in the tree is deleted, if the object has a parent, the destructor automatically removes the object from its parent. 所以你可以放心地删除，而不必担心析构两次。</p><p>另外在 disconnect 的信号的帮助里也有说到：</p><pre class=help><code>[signal] void QAbstractSocket::disconnected()
Warning: If you need to delete the sender() of this signal in a slot connected to it, use the deleteLater() function.</code></pre></div><div id=Rsidebar><div id=Avatar><img alt=avatar src=/avatar.jpg></div><ul><li><a href=/about>About Me</a></li><li><a href=/donate>Donate Me</a></li><li><a href=/>Ben's Blog</a></li></ul>除非注明，本博客所有文章皆为原创。<br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</div></div><div class=footer><div id=tags><a href=https://bensyz.github.io/blog/tags><i class="fas fa-tags"></i></a>
Keywords:<ul><li><a href=https://bensyz.github.io/blog/tags/network>network</a></li><li><a href=https://bensyz.github.io/blog/tags/socket>socket</a></li><li><a href=https://bensyz.github.io/blog/tags/qt>qt</a></li><li><a href=https://bensyz.github.io/blog/tags/c>c</a></li></ul></div><footer><hr><a href=/>Ben's Blog</a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33028102001039"><img alt=public_safety_record src=/icons/public_safety_icon.png>浙公网安备 33028102001039号</a>
<a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备2021032097号-1</a></footer></div></div></body></html>