<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>网络断连分析工具介绍</title><script src=/js/if_mobile.js></script>
<script>!function(){$("pre > code").each(function(){var s,n=$(this).parent().attr("class");n==null||n===""?$(this).addClass("hljs"):(s={js:"javascript"},s[n]&&(n=s[n]),$(this).addClass(n))})}</script><link rel=stylesheet href=/css/hljs/snazzy.css><link rel=stylesheet href=/css/hljs/line-numbers.min.css><script src=/js/hljs/highlight.min.js></script>
<script src=/js/hljs/highlightjs-line-numbers.min.js></script>
<script>hljs.highlightAll()</script><script>hljs.initLineNumbersOnLoad()</script><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/footer.css><link rel=stylesheet href=/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=icon id=light-scheme-icon href=/favicons/favicon_B_Light.ico type=image/x-icon><link rel=icon id=dark-scheme-icon href=/favicons/favicon_B_Dark.ico type=image/x-icon><script src=/js/favicon.js></script></head><body><div class=container><div class=header><h1>网络断连分析工具介绍</h1>Tue, 2022-04-26<br>本文最后修改于 Wed, 2022-04-27<hr></div><div class=middle><div id=TitleWithToc><div id=TitleOfToc>网络断连分析工具介绍</div></div><div id=content><h1 id=网络断连分析工具介绍>网络断连分析工具介绍</h1><p>[toc]</p><h2 id=抓包工具数据链路层及之上>抓包工具（数据链路层及之上）</h2><h3 id=tcpdump><code>tcpdump</code></h3><ol type=1><li>网络层：</li></ol><pre class=console><code># tcpdump -i eth0</code></pre><ol start=2 type=1><li>数据链路层</li></ol><pre class=console><code># tcpdump -e -i eth0</code></pre><h3 id=wireshark><code>wireshark</code></h3><p><code>wireshark</code> 还是更香一点，可以直接抓，抓完还可以看流量图 (statistic-Flow graph)(一应一答的那种)</p><p>需要注意的是通讯双方的 <code>wireshark</code> 版本要保持一致，老版本的 sequence number 和新版本的对不上</p><p>我们这次使用的是 Version 3.6.3，如果没有可以自行 <a href=https://1.as.dl.wireshark.org/src/wireshark-3.6.3.tar.xz>下载</a> 编译，编译方法查看 INSTALL 文件，对于 Ubnutu 来说</p><pre class=console><code># ./tools/debian-setup.sh
# mkdir build
# cmake -DCMAKE_INSTALL_PREFIX ..
# make -j4
# make install</code></pre><h2 id=phy-芯片的查看物理层>PHY 芯片的查看（物理层）</h2><p>rtl8169 的手册：<a href=https://www.semiee.com/file/EOL2/Realtek-RTL8168-LF.pdf class=uri>https://www.semiee.com/file/EOL2/Realtek-RTL8168-LF.pdf</a></p><p>PHY 分 MAC 侧和 PHY 侧，我们这次主要看 PHY 是否有变化，以及 中断 mask 是否有变化导致网络中断上不来。</p><h3 id=网上找的一个小工具-mdio>网上找的一个小工具 mdio</h3><p>我先是找到了这个<a href=https://blog.csdn.net/qq_40083589/article/details/102495601>工具</a>，但它只支持 PHY 侧的状态查询</p><div class=sourceCode id=cb4><pre class="sourceCode c"><code class="sourceCode c"><span id=cb4-1><a href=#cb4-1 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;stdlib.h&gt;</span></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;string.h&gt;</span></span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;linux/mii.h&gt;</span></span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;sys/types.h&gt;</span></span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;sys/socket.h&gt;</span></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;sys/ioctl.h&gt;</span></span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;net/if.h&gt;</span></span>
<span id=cb4-9><a href=#cb4-9 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;linux/sockios.h&gt;</span></span>
<span id=cb4-10><a href=#cb4-10 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;linux/types.h&gt;</span></span>
<span id=cb4-11><a href=#cb4-11 aria-hidden=true></a><span class=pp>#include </span><span class=im>&lt;netinet/in.h&gt;</span></span>
<span id=cb4-12><a href=#cb4-12 aria-hidden=true></a></span>
<span id=cb4-13><a href=#cb4-13 aria-hidden=true></a></span>
<span id=cb4-14><a href=#cb4-14 aria-hidden=true></a><span class=pp>#define reteck(ret)    \</span></span>
<span id=cb4-15><a href=#cb4-15 aria-hidden=true></a><span class=pp>        if(ret &lt; 0){    \</span></span>
<span id=cb4-16><a href=#cb4-16 aria-hidden=true></a><span class=pp>            printf(&quot;%m! \&quot;%s\&quot; : line: %d\n&quot;, __func__, __LINE__);  \</span></span>
<span id=cb4-17><a href=#cb4-17 aria-hidden=true></a><span class=pp>            goto lab;  \</span></span>
<span id=cb4-18><a href=#cb4-18 aria-hidden=true></a><span class=pp>        }</span></span>
<span id=cb4-19><a href=#cb4-19 aria-hidden=true></a></span>
<span id=cb4-20><a href=#cb4-20 aria-hidden=true></a><span class=pp>#define help() \</span></span>
<span id=cb4-21><a href=#cb4-21 aria-hidden=true></a><span class=pp>    printf(&quot;mdio:\n&quot;);                  \</span></span>
<span id=cb4-22><a href=#cb4-22 aria-hidden=true></a><span class=pp>    printf(&quot;read operation: mdio reg_addr\n&quot;);          \</span></span>
<span id=cb4-23><a href=#cb4-23 aria-hidden=true></a><span class=pp>    printf(&quot;write operation: mdio reg_addr value\n&quot;);    \</span></span>
<span id=cb4-24><a href=#cb4-24 aria-hidden=true></a><span class=pp>    printf(&quot;For example:\n&quot;);            \</span></span>
<span id=cb4-25><a href=#cb4-25 aria-hidden=true></a><span class=pp>    printf(&quot;mdio eth0 1\n&quot;);            \</span></span>
<span id=cb4-26><a href=#cb4-26 aria-hidden=true></a><span class=pp>    printf(&quot;mdio eth0 0 0x12\n\n&quot;);      \</span></span>
<span id=cb4-27><a href=#cb4-27 aria-hidden=true></a><span class=pp>    exit(0);</span></span>
<span id=cb4-28><a href=#cb4-28 aria-hidden=true></a></span>
<span id=cb4-29><a href=#cb4-29 aria-hidden=true></a><span class=dt>int</span> sockfd;</span>
<span id=cb4-30><a href=#cb4-30 aria-hidden=true></a></span>
<span id=cb4-31><a href=#cb4-31 aria-hidden=true></a><span class=dt>int</span> main(<span class=dt>int</span> argc, <span class=dt>char</span> *argv[]){</span>
<span id=cb4-32><a href=#cb4-32 aria-hidden=true></a>        </span>
<span id=cb4-33><a href=#cb4-33 aria-hidden=true></a>    <span class=cf>if</span>(argc == <span class=dv>1</span> || !strcmp(argv[<span class=dv>1</span>], <span class=st>&quot;-h&quot;</span>)){</span>
<span id=cb4-34><a href=#cb4-34 aria-hidden=true></a>        help();</span>
<span id=cb4-35><a href=#cb4-35 aria-hidden=true></a>    }</span>
<span id=cb4-36><a href=#cb4-36 aria-hidden=true></a>    </span>
<span id=cb4-37><a href=#cb4-37 aria-hidden=true></a>    <span class=kw>struct</span> mii_ioctl_data *mii = NULL;</span>
<span id=cb4-38><a href=#cb4-38 aria-hidden=true></a>    <span class=kw>struct</span> ifreq ifr;</span>
<span id=cb4-39><a href=#cb4-39 aria-hidden=true></a>    <span class=dt>int</span> ret;</span>
<span id=cb4-40><a href=#cb4-40 aria-hidden=true></a></span>
<span id=cb4-41><a href=#cb4-41 aria-hidden=true></a>    memset(&amp;ifr, <span class=dv>0</span>, <span class=kw>sizeof</span>(ifr));</span>
<span id=cb4-42><a href=#cb4-42 aria-hidden=true></a>    strncpy(ifr.ifr_name, argv[<span class=dv>1</span>], IFNAMSIZ - <span class=dv>1</span>);</span>
<span id=cb4-43><a href=#cb4-43 aria-hidden=true></a></span>
<span id=cb4-44><a href=#cb4-44 aria-hidden=true></a>    sockfd = socket(PF_LOCAL, SOCK_DGRAM, <span class=dv>0</span>);</span>
<span id=cb4-45><a href=#cb4-45 aria-hidden=true></a>    reteck(sockfd);</span>
<span id=cb4-46><a href=#cb4-46 aria-hidden=true></a></span>
<span id=cb4-47><a href=#cb4-47 aria-hidden=true></a>    <span class=co>//get phy address in smi bus</span></span>
<span id=cb4-48><a href=#cb4-48 aria-hidden=true></a>    ret = ioctl(sockfd, SIOCGMIIPHY, &amp;ifr);</span>
<span id=cb4-49><a href=#cb4-49 aria-hidden=true></a>    reteck(ret);</span>
<span id=cb4-50><a href=#cb4-50 aria-hidden=true></a></span>
<span id=cb4-51><a href=#cb4-51 aria-hidden=true></a>    mii = (<span class=kw>struct</span> mii_ioctl_data*)&amp;ifr.ifr_data;</span>
<span id=cb4-52><a href=#cb4-52 aria-hidden=true></a>    </span>
<span id=cb4-53><a href=#cb4-53 aria-hidden=true></a></span>
<span id=cb4-54><a href=#cb4-54 aria-hidden=true></a>    <span class=cf>if</span>(argc == <span class=dv>3</span>){</span>
<span id=cb4-55><a href=#cb4-55 aria-hidden=true></a></span>
<span id=cb4-56><a href=#cb4-56 aria-hidden=true></a>        mii-&gt;reg_num    = (<span class=dt>uint16_t</span>)strtoul(argv[<span class=dv>2</span>], NULL, <span class=dv>0</span>);</span>
<span id=cb4-57><a href=#cb4-57 aria-hidden=true></a>        </span>
<span id=cb4-58><a href=#cb4-58 aria-hidden=true></a>        ret = ioctl(sockfd, SIOCGMIIREG, &amp;ifr);</span>
<span id=cb4-59><a href=#cb4-59 aria-hidden=true></a>        reteck(ret);</span>
<span id=cb4-60><a href=#cb4-60 aria-hidden=true></a>        </span>
<span id=cb4-61><a href=#cb4-61 aria-hidden=true></a>    </span>
<span id=cb4-62><a href=#cb4-62 aria-hidden=true></a>        printf(<span class=st>&quot;read phy addr: 0x%x  reg: 0x%x  value : 0x%x</span><span class=sc>\n\n</span><span class=st>&quot;</span>, mii-&gt;phy_id, mii-&gt;reg_num, mii-&gt;val_out);</span>
<span id=cb4-63><a href=#cb4-63 aria-hidden=true></a> }<span class=cf>else</span> <span class=cf>if</span>(argc == <span class=dv>4</span>){</span>
<span id=cb4-64><a href=#cb4-64 aria-hidden=true></a></span>
<span id=cb4-65><a href=#cb4-65 aria-hidden=true></a>        mii-&gt;reg_num    = (<span class=dt>uint16_t</span>)strtoul(argv[<span class=dv>2</span>], NULL, <span class=dv>0</span>);</span>
<span id=cb4-66><a href=#cb4-66 aria-hidden=true></a>        mii-&gt;val_in    = (<span class=dt>uint16_t</span>)strtoul(argv[<span class=dv>3</span>], NULL, <span class=dv>0</span>);</span>
<span id=cb4-67><a href=#cb4-67 aria-hidden=true></a></span>
<span id=cb4-68><a href=#cb4-68 aria-hidden=true></a>        ret = ioctl(sockfd, SIOCSMIIREG, &amp;ifr);</span>
<span id=cb4-69><a href=#cb4-69 aria-hidden=true></a>        reteck(ret);</span>
<span id=cb4-70><a href=#cb4-70 aria-hidden=true></a></span>
<span id=cb4-71><a href=#cb4-71 aria-hidden=true></a>        printf(<span class=st>&quot;write phy addr: 0x%x  reg: 0x%x  value : 0x%x</span><span class=sc>\n\n</span><span class=st>&quot;</span>, mii-&gt;phy_id, mii-&gt;reg_num, mii-&gt;val_in);</span>
<span id=cb4-72><a href=#cb4-72 aria-hidden=true></a>    }</span>
<span id=cb4-73><a href=#cb4-73 aria-hidden=true></a></span>
<span id=cb4-74><a href=#cb4-74 aria-hidden=true></a>lab:</span>
<span id=cb4-75><a href=#cb4-75 aria-hidden=true></a>    close(sockfd);</span>
<span id=cb4-76><a href=#cb4-76 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb4-77><a href=#cb4-77 aria-hidden=true></a>}</span></code></pre></div><p>编译后使用方法：</p><ul><li>读取：</li></ul><pre class=console><code># ./mdio eth0 0x00</code></pre><ul><li>修改：</li></ul><pre class=console><code># ./mdio eth0 0x00 0x00</code></pre><h3 id=ethtool><code>ethtool</code></h3><p>ethtool 可以同时直接看 PHY侧 和 MAC 侧的 PHY 芯片的状态：</p><pre class=console><code>ethtool -d eth0</code></pre><pre class=output><code>RealTek RTL8168g/8111g registers:
--------------------------------------------------------
0x00: MAC Address                      ma:c0:ad:dr:es:s0
0x08: Multicast Address Filter     0x02020040 0x80400083
0x10: Dump Tally Counter Command   0x1303b000 0x00000001
0x20: Tx Normal Priority Ring Addr 0x02a25000 0x00000001
0x28: Tx High Priority Ring Addr   0x00000000 0x00000000
0x30: Flash memory read/write                 0x00000000
0x34: Early Rx Byte Count                              0
0x36: Early Rx Status                               0x00
0x37: Command                                       0x0c
      Rx on, Tx on
0x3C: Interrupt Mask                              0x003f
      LinkChg RxNoBuf TxErr TxOK RxErr RxOK
0x3E: Interrupt Status                            0x0000

0x40: Tx Configuration                        0x53900f80
0x44: Rx Configuration                        0x0002cf0e
0x48: Timer count                             0x00000000
0x4C: Missed packet counter                     0x000000
0x50: EEPROM Command                                0x10
0x51: Config 0                                      0x00
0x52: Config 1                                      0xcf
0x53: Config 2                                      0x1c
0x54: Config 3                                      0x60
0x55: Config 4                                      0x11
0x56: Config 5                                      0x00
0x58: Timer interrupt                         0x00000000
0x5C: Multiple Interrupt Select                   0x0000
0x60: PHY access                              0x00000000
0x64: TBI control and status                  0x00000000
0x68: TBI Autonegotiation advertisement (ANAR)    0x0000
0x6A: TBI Link partner ability (LPAR)             0x0000
0x6C: PHY status                                    0x84
0x84: PM wakeup frame 0            0x00000000 0x00000000
0x8C: PM wakeup frame 1            0x00000000 0x00000000
0x94: PM wakeup frame 2 (low)      0x00000000 0x00000000
0x9C: PM wakeup frame 2 (high)     0x00000000 0x00000000
0xA4: PM wakeup frame 3 (low)      0x00000000 0x00000000
0xAC: PM wakeup frame 3 (high)     0x00000000 0x00000000
0xB4: PM wakeup frame 4 (low)      0x00000000 0xd20a0000
0xBC: PM wakeup frame 4 (high)     0x00000000 0x00000000
0xC4: Wakeup frame 0 CRC                          0x0000
0xC6: Wakeup frame 1 CRC                          0x0000
0xC8: Wakeup frame 2 CRC                          0x0000
0xCA: Wakeup frame 3 CRC                          0x0000
0xCC: Wakeup frame 4 CRC                          0x0000
0xDA: RX packet maximum size                      0x4000
0xE0: C+ Command                                  0x2060
      VLAN de-tagging
      RX checksumming
0xE2: Interrupt Mitigation                        0x0000
      TxTimer:       0
      TxPackets:     0
      RxTimer:       0
      RxPackets:     0
0xE4: Rx Ring Addr                 0x03fef000 0x00000001
0xEC: Early Tx threshold                            0x27
0xF0: Func Event                              0x0000003f
0xF4: Func Event Mask                         0x00000000
0xF8: Func Preset State                       0x00000003
0xFC: Func Force Event                        0x00000000</code></pre><p>但ethtool 并不支持解析 r8168 驱动，只会返回给我们裸数据，所以我们需要添加r8168，用r8169来解析这个裸数据，并自己编译。添加的位置：是 <code>driver_list[]={}</code>。虽说这可能会有些问题，有些状态不对，但由于我们只需看中断mask，所以可以直接拿来用。根据从手册上说的，r8168 和 r8169 中断mask的位置是同一个所以我们可以直接看了。</p></div><div id=Rsidebar><div id=Avatar><img alt=avatar src=/avatar.jpg></div><ul><li><a href=/about>About Me</a></li><li><a href=/donate>Donate Me</a></li><li><a href=/>Ben's Blog</a></li></ul>除非注明，本博客所有文章皆为原创。<br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</div></div><div class=footer><div id=tags><a href=https://bensyz.github.io/blog/tags><i class="fas fa-tags"></i></a>
Keywords:<ul><li><a href=https://bensyz.github.io/blog/tags/network>network</a></li><li><a href=https://bensyz.github.io/blog/tags/tool>tool</a></li><li><a href=https://bensyz.github.io/blog/tags/ethtool>ethtool</a></li></ul></div><footer><hr><a href=/>Ben's Blog</a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33028102001039"><img alt=public_safety_record src=/icons/public_safety_icon.png>浙公网安备 33028102001039号</a>
<a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备2021032097号-1</a></footer></div></div></body></html>