<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>struct initialization in C Lang</title><script src=/js/if_mobile.js></script>
<script>!function(){$("pre > code").each(function(){var s,n=$(this).parent().attr("class");n==null||n===""?$(this).addClass("hljs"):(s={js:"javascript"},s[n]&&(n=s[n]),$(this).addClass(n))})}</script><link rel=stylesheet href=/css/hljs/snazzy.css><link rel=stylesheet href=/css/hljs/line-numbers.min.css><script src=/js/hljs/highlight.min.js></script>
<script src=/js/hljs/highlightjs-line-numbers.min.js></script>
<script>hljs.highlightAll()</script><script>hljs.initLineNumbersOnLoad()</script><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/footer.css><link rel=stylesheet href=/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=icon id=light-scheme-icon href=/favicons/favicon_B_Light.ico type=image/x-icon><link rel=icon id=dark-scheme-icon href=/favicons/favicon_B_Dark.ico type=image/x-icon><script src=/js/favicon.js></script></head><body><div class=container><div class=header><h1>struct initialization in C Lang</h1>Sat, 2023-05-20<br>本文最后修改于 Sat, 2024-10-05<hr></div><div class=middle><div id=TitleWithToc><div id=TitleOfToc>struct initialization in C Lang</div></div><div id=content><h2 id=introduction>Introduction</h2><p>看内核源码关于任务初始化的时候看到一个很奇怪的写法：<code>struct task_struct init_task = INIT_TASK(init_task);</code>，一个没被定义变量怎么可以传给一个函数，用来 初始化它自己。</p><p>我们把原始代码用一下这个 demo 展示：</p><div class=sourceCode id=cb1><pre class="sourceCode c"><code class="sourceCode c"><span id=cb1-1><a href=#cb1-1 aria-hidden=true></a><span class=kw>struct</span> myStruct {</span>
<span id=cb1-2><a href=#cb1-2 aria-hidden=true></a>  <span class=kw>struct</span> myStruct *self;</span>
<span id=cb1-3><a href=#cb1-3 aria-hidden=true></a>  <span class=dt>int</span> a;</span>
<span id=cb1-4><a href=#cb1-4 aria-hidden=true></a>  <span class=dt>int</span> b;</span>
<span id=cb1-5><a href=#cb1-5 aria-hidden=true></a>};</span>
<span id=cb1-6><a href=#cb1-6 aria-hidden=true></a></span>
<span id=cb1-7><a href=#cb1-7 aria-hidden=true></a><span class=pp>#define INIT_TASK(tsk){\</span></span>
<span id=cb1-8><a href=#cb1-8 aria-hidden=true></a><span class=pp>    .self = &amp;tsk,      \</span></span>
<span id=cb1-9><a href=#cb1-9 aria-hidden=true></a><span class=pp>    .a = 0,            \</span></span>
<span id=cb1-10><a href=#cb1-10 aria-hidden=true></a><span class=pp>    .b = 1,            \</span></span>
<span id=cb1-11><a href=#cb1-11 aria-hidden=true></a><span class=pp>}</span></span>
<span id=cb1-12><a href=#cb1-12 aria-hidden=true></a></span>
<span id=cb1-13><a href=#cb1-13 aria-hidden=true></a><span class=dt>int</span> main() {</span>
<span id=cb1-14><a href=#cb1-14 aria-hidden=true></a>    <span class=kw>struct</span> myStruct init_task = INIT_TASK(init_task);</span>
<span id=cb1-15><a href=#cb1-15 aria-hidden=true></a>    <span class=co>/*</span></span>
<span id=cb1-16><a href=#cb1-16 aria-hidden=true></a><span class=co>     * 展开后：</span></span>
<span id=cb1-17><a href=#cb1-17 aria-hidden=true></a><span class=co>     * struct myStruct init_task = { .self = &amp;init_task, .a = 0, .b = 1, };</span></span>
<span id=cb1-18><a href=#cb1-18 aria-hidden=true></a><span class=co>     */</span></span>
<span id=cb1-19><a href=#cb1-19 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb1-20><a href=#cb1-20 aria-hidden=true></a>}</span></code></pre></div><h2 id=whats-this>What’s this?</h2><ol type=1><li><code>INIT_TASK</code> 是一个宏，由于宏是在编译时展开，所以 <code>init_task</code> 其实并不是作为 参数被传入的，而是在这里展开。同时 <code>INIT_TASK</code> 只用了 <code>init_task</code> 的地址，而 并没有用 <code>init_task</code> 这个结构体本身。</li><li><code>{.self = &amp;tsk, .a = 0, .b = 1,}</code> 是什么？结构体的初始化。</li></ol><h3 id=何时分配-init_task-的地址>何时分配 <code>init_task</code> 的地址</h3><p>那 <code>init_task</code> 的地址是在什么时候分配的呢？这个结构体的赋值有些复杂，因为涉及到 取址。我们看一个简单的例子：</p><div class=sourceCode id=cb2><pre class="sourceCode c"><code class="sourceCode c"><span id=cb2-1><a href=#cb2-1 aria-hidden=true></a><span class=dt>int</span> main(){</span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true></a>    <span class=dt>int</span> a = <span class=dv>0</span>;</span>
<span id=cb2-3><a href=#cb2-3 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb2-4><a href=#cb2-4 aria-hidden=true></a>}</span></code></pre></div><div class=sourceCode id=cb3><pre class="sourceCode asm"><code class="sourceCode fasm"><span id=cb3-1><a href=#cb3-1 aria-hidden=true></a><span class=bu>push</span>   %<span class=kw>rbp</span></span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true></a><span class=bu>mov</span>    %<span class=kw>rsp</span>,%<span class=kw>rbp</span></span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true></a>movl   <span class=dv>$</span><span class=bn>0x0,</span>-<span class=bn>0x4</span>(%<span class=kw>rbp</span>)</span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true></a><span class=bu>mov</span>    <span class=dv>$</span><span class=bn>0x0,</span>%<span class=kw>eax</span></span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true></a><span class=bu>pop</span>    %<span class=kw>rbp</span></span></code></pre></div><pre class=gdb><code>(gdb) p &amp;a
$1 = (int *) 0x7fffffffd5cc
(gdb) p $rbp
$2 = (void *) 0x7fffffffd5d0
# 基地址 rbp: 0x7fffffffd5d0
# movl   $0x0,-0x4(%rbp) 将 0x0 赋值给 rbp-4 也就是 0x7fffffffd5cc</code></pre><p>所以这些栈上的变量的地址是基于 <code>rbp</code> 的，也就是说相对地址是由汇编代码决定的，而 汇编代码来自 C 的代码。也就是这份代码结构决定了变量 a 的地址的存在。</p><h4 id=验证是否可以用函数来替代宏>验证：是否可以用函数来替代宏</h4><p>既然我们说，宏（<code>INIT_TASK</code>）只使用了 <code>init_task</code> 的地址，而 <code>init_task</code> 的地址 是由这份代码结构决定的。也就是说看起来传参传的是一个未定的变量（<code>init_task</code>）， 其实传的是一个固定的值（<code>&amp;init_task</code>）。那这完全符合函数的操作。</p><div class=sourceCode id=cb5><pre class="sourceCode c"><code class="sourceCode c"><span id=cb5-1><a href=#cb5-1 aria-hidden=true></a><span class=kw>struct</span> myStruct {</span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true></a>  <span class=kw>struct</span> myStruct *self;</span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true></a>  <span class=dt>int</span> a;</span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true></a>  <span class=dt>int</span> b;</span>
<span id=cb5-5><a href=#cb5-5 aria-hidden=true></a>};</span>
<span id=cb5-6><a href=#cb5-6 aria-hidden=true></a></span>
<span id=cb5-7><a href=#cb5-7 aria-hidden=true></a><span class=kw>struct</span> myStruct FUNC_INIT_TASK(<span class=kw>struct</span> myStruct * tsk){</span>
<span id=cb5-8><a href=#cb5-8 aria-hidden=true></a>    tsk-&gt;self = tsk;</span>
<span id=cb5-9><a href=#cb5-9 aria-hidden=true></a>    tsk-&gt;a=<span class=dv>0</span>;</span>
<span id=cb5-10><a href=#cb5-10 aria-hidden=true></a>    tsk-&gt;b=<span class=dv>0</span>;</span>
<span id=cb5-11><a href=#cb5-11 aria-hidden=true></a>    <span class=cf>return</span> *tsk;</span>
<span id=cb5-12><a href=#cb5-12 aria-hidden=true></a>}</span>
<span id=cb5-13><a href=#cb5-13 aria-hidden=true></a></span>
<span id=cb5-14><a href=#cb5-14 aria-hidden=true></a><span class=dt>int</span> main() {</span>
<span id=cb5-15><a href=#cb5-15 aria-hidden=true></a>    <span class=kw>struct</span> myStruct func_init_task = FUNC_INIT_TASK(&amp;func_init_task);</span>
<span id=cb5-16><a href=#cb5-16 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb5-17><a href=#cb5-17 aria-hidden=true></a>}</span></code></pre></div><h3 id=结构体内部用结构体本身>结构体内部用结构体本身？</h3><p>我们把 <code>&amp;init_task</code> 赋给了 <code>init_task.self</code>，看起来有点像“鸡生蛋，蛋生鸡”的问题， 其实不然，就像上节中说的，<code>&amp;init_task</code> 和 <code>init_task</code> 是两回事，对 <code>&amp;init_task</code> 我们只是借用了 <code>init_task</code> 来取到这个地址。来看一个真正的“鸡生蛋，蛋生鸡”的代码：</p><div class=sourceCode id=cb6><pre class="sourceCode c"><code class="sourceCode c"><span id=cb6-1><a href=#cb6-1 aria-hidden=true></a><span class=kw>struct</span> myStruct {</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true></a>  <span class=kw>struct</span> myStruct self; <span class=co>// field has incomplete type &#39;struct myStruct&#39; (ccls 2)</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true></a>  <span class=dt>int</span> a;</span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true></a>  <span class=dt>int</span> b;</span>
<span id=cb6-5><a href=#cb6-5 aria-hidden=true></a>};</span>
<span id=cb6-6><a href=#cb6-6 aria-hidden=true></a></span>
<span id=cb6-7><a href=#cb6-7 aria-hidden=true></a><span class=pp>#define INIT_TASK(tsk){\</span></span>
<span id=cb6-8><a href=#cb6-8 aria-hidden=true></a><span class=pp>    .self = tsk,       \</span></span>
<span id=cb6-9><a href=#cb6-9 aria-hidden=true></a><span class=pp>    .a = 0,            \</span></span>
<span id=cb6-10><a href=#cb6-10 aria-hidden=true></a><span class=pp>    .b = 1,            \</span></span>
<span id=cb6-11><a href=#cb6-11 aria-hidden=true></a><span class=pp>}</span></span>
<span id=cb6-12><a href=#cb6-12 aria-hidden=true></a></span>
<span id=cb6-13><a href=#cb6-13 aria-hidden=true></a><span class=dt>int</span> main() {</span>
<span id=cb6-14><a href=#cb6-14 aria-hidden=true></a>    <span class=kw>struct</span> myStruct init_task = INIT_TASK(init_task);</span>
<span id=cb6-15><a href=#cb6-15 aria-hidden=true></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb6-16><a href=#cb6-16 aria-hidden=true></a>}</span></code></pre></div><p>我们会发现，linter 直接在定义结构体的时候就报错了，因为它不知道 <code>myStruct</code> 有多 大，或者说这种定义本身就是一种矛盾：外部的 <code>myStruct</code> 一定比内部的 <code>myStruct</code> 大两个 <code>int</code> 的大小。</p><p>其实这个看似“鸡生蛋，蛋生鸡”的问题我们在数据结构中写链表的时候就用到了。</p><p>另外，对 64 bit 的 Linux 来说，这个 <code>struct myStruct *self</code> 的本质其实是 <code>long</code>。 关于各个变量的长度，有机会再聊聊，Linux 的 long 和 Windows 的 long 是不一样的。 （TODO）</p></div><div id=Rsidebar><div id=Avatar><img alt=avatar src=/avatar.jpg></div><ul><li><a href=/about>About Me</a></li><li><a href=/donate>Donate Me</a></li><li><a href=/>Ben's Blog</a></li></ul>除非注明，本博客所有文章皆为原创。<br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</div></div><div class=footer><div id=tags><a href=https://bensyz.github.io/blog/tags><i class="fas fa-tags"></i></a>
Keywords:<ul><li><a href=https://bensyz.github.io/blog/tags/Linux-kernel>Linux kernel</a></li><li><a href=https://bensyz.github.io/blog/tags/C-Lang>C-Lang</a></li><li><a href=https://bensyz.github.io/blog/tags/struct>struct</a></li></ul></div><footer><hr><a href=/>Ben's Blog</a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33028102001039"><img alt=public_safety_record src=/icons/public_safety_icon.png>浙公网安备 33028102001039号</a>
<a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备2021032097号-1</a></footer></div></div></body></html>