<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rk3588 on Ben's Blog</title><link>https://bensyz.github.io/blog/tags/rk3588/</link><description>Recent content in rk3588 on Ben's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 23 Nov 2023 10:51:55 +0800</lastBuildDate><atom:link href="https://bensyz.github.io/blog/tags/rk3588/index.xml" rel="self" type="application/rss+xml"/><item><title>RK3588 PCIe Introduction</title><link>https://bensyz.github.io/blog/blogs/rk3588_PCIe_intro/</link><pubDate>Thu, 23 Nov 2023 10:51:55 +0800</pubDate><guid>https://bensyz.github.io/blog/blogs/rk3588_PCIe_intro/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>起因是发现启动的时候 PCIe 有关于 &lt;code>fe160000&lt;/code> 的报错信息:&lt;/p>
&lt;pre class="dmesg">&lt;code>[ 1.712561] rk-pcie fe160000.pcie: invalid prsnt-gpios property in node
[ 1.728638] rk-pcie fe160000.pcie: IRQ msi not found
[ 1.728645] rk-pcie fe160000.pcie: use outband MSI support
[ 1.728647] rk-pcie fe160000.pcie: Missing *config* reg space
[ 1.728660] rk-pcie fe160000.pcie: host bridge /pcie@fe160000 ranges:
[ 1.728670] rk-pcie fe160000.pcie: err 0x00f1000000..0x00f10fffff -&amp;gt; 0x00f1000000
[ 1.728677] rk-pcie fe160000.pcie: IO 0x00f1100000..0x00f11fffff -&amp;gt; 0x00f1100000
[ 1.728686] rk-pcie fe160000.pcie: MEM 0x00f1200000..0x00f1ffffff -&amp;gt; 0x00f1200000
[ 1.728691] rk-pcie fe160000.pcie: MEM 0x0940000000..0x097fffffff -&amp;gt; 0x0940000000
[ 1.728712] rk-pcie fe160000.pcie: Missing *config* reg space
[ 1.728739] rk-pcie fe160000.pcie: invalid resource
[ 1.934114] rk-pcie fe160000.pcie: PCIe Linking... LTSSM is 0x0
[ 1.959670] rk-pcie fe160000.pcie: PCIe Linking... LTSSM is 0x1
[ 1.986337] rk-pcie fe160000.pcie: PCIe Linking... LTSSM is 0x0
[ 2.013002] rk-pcie fe160000.pcie: PCIe Linking... LTSSM is 0x0
[ 2.043004] rk-pcie fe160000.pcie: PCIe Linking... LTSSM is 0x0
[ 2.069669] rk-pcie fe160000.pcie: PCIe Linking... LTSSM is 0x0
[ 4.629670] rk-pcie fe160000.pcie: PCIe Link Fail
[ 4.629679] rk-pcie fe160000.pcie: failed to initialize host&lt;/code>&lt;/pre>
&lt;p>于是阅读 RK3588 SDK 中关于 PCIe 的文档 &lt;code>docs/cn/Common/PCIe/Rockchip_Developer_Guide_PCIe_CN.pdf&lt;/code>，想了解这个错究竟是什么，对于纯新手的我来说不是很好理解，因而边画，边学习，整理如下，如有错误之处，还请谅解并告知于我，十分感谢。&lt;/p>
&lt;h2 id="rks-intro-and-picture">RK’s Intro and Picture&lt;/h2>
&lt;p>RK 有一段关于 PCIe Controller 使用限制的说明，和一张 Big Picture，不是太好理解，于是我把这张图拆开来，画了几张图。&lt;/p>
&lt;p>&lt;img src="./figures/rk3588_PCIe_use_limitation.png" alt="rk3588_PCIe_use_limitation" />[1] &lt;img src="./figures/rk3588_PCIe_big_picture.png" alt="rk3588_PCIe_big_picture" />[2]&lt;/p>
&lt;h2 id="phy-and-controller">PHY and Controller&lt;/h2>
&lt;ul>
&lt;li>PHY: Chip。把控制器发过来的信号做处理，然后再发出去。这种处理是为了方便传输，类似网络中的 rgmii（上游）和 8bit/10bit（下游）。简单来说 PHY 的上下是两种信号。&lt;/li>
&lt;li>控制器：实现一定的功能的 Chip。&lt;/li>
&lt;li>Cable: 网线。by ChatGPT: difference of PHY and cable: The PHY layer manages the signaling and encoding on the cable, ensuring reliable communication between devices.&lt;/li>
&lt;/ul>
&lt;h3 id="pcie-phy">PCIe PHY&lt;/h3>
&lt;ul>
&lt;li>RK3588 有两种 PCIe PHY
&lt;ul>
&lt;li>一种是 PCIe 3.0 的 PHY 有 1 个&lt;/li>
&lt;li>一种是 PCIe 2.0 的 PHY 有 3 个&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>PCIe 3.0 有 4 条 Lane&lt;/li>
&lt;li>每个 PCIe 2.0 只有一条 1 个Lane&lt;/li>
&lt;/ul>
&lt;figure>
&lt;img src="./figures/PCIe_PHY.drawio.png" alt="" />&lt;figcaption>PCIe_PHY.drawio&lt;/figcaption>
&lt;/figure>
&lt;h3 id="connect-to-pcie-controller">Connect to PCIe Controller&lt;/h3>
&lt;p>RK3588共有5个PCIe的控制器，硬件IP是一样的，配置不一样，&lt;/p>
&lt;ul>
&lt;li>1 个 4 Lane 控制器 支持 DM（dual mode）模式，可以作为 RC(Root Complex) 和 EP(End Point) 使用&lt;/li>
&lt;li>1 个 2 Lane 控制器 只能作为 RC 使用&lt;/li>
&lt;li>3 个 1 Lane 控制器 均只能作为 RC 使用&lt;/li>
&lt;/ul>
&lt;p>关于 RC 和 EP，可以详见我的这篇文章 &lt;a href="./PCIe_and_lspci">PCIe 和 lspci&lt;/a>。对于 RK3588 这个 PCIe 控制器的 EP 模式，其实此时，是将 RK3588 所在的 PCB 板当作板卡，就像显卡一样，插在其他主机的 PCIe 槽上，作为从设备。就像显卡、RTL8168 系列芯片一样。&lt;/p>
&lt;p>PCIe PHY 受 PCIe Controller 控制，所以上面几个 PHY 的上游需要接 PCIe Controller。接法有很多，最简单的接法是这样子的：&lt;/p>
&lt;figure>
&lt;img src="./figures/PCIe_4Lane.drawio.png" alt="" />&lt;figcaption>PCIe_4Lane.drawio&lt;/figcaption>
&lt;/figure>
&lt;ul>
&lt;li>关于 Port，简单来说一个 Port 接一个设备&lt;/li>
&lt;/ul>
&lt;p>也可以把 PCIe 3.0 的 PHY 拆开使用，拆成两个 Port&lt;/p>
&lt;figure>
&lt;img src="./figures/PCIe_4Lane_split2.drawio.png" alt="" />&lt;figcaption>PCIe_4Lane_split2.drawio&lt;/figcaption>
&lt;/figure>
&lt;p>PCIe 3.0 的 PHY 还可以再细拆，拆成 4 个 Port&lt;/p>
&lt;figure>
&lt;img src="./figures/PCIe_4Lane_split4.drawio.png" alt="" />&lt;figcaption>PCIe_4Lane_split4.drawio&lt;/figcaption>
&lt;/figure>
&lt;p>由于控制器数量限制，所以有两条 Lane 空出来了。这两条 Lane 空着也是空着，为什么不把它再利用起来呢，于是 RK 把这两条多出来的 Lane 和 USB 和 SATA 做了复用，也就是所谓的 MUX。所谓 MUX 就是同一条物理线路上，我可以传输这种信号，也可以传输另一种信号，我复用了这条线路，但是这里的“可以”和“也可以”只能选一个，不能既选这个又选那个，选了一个就不能选另外一个了。&lt;/p>
&lt;figure>
&lt;img src="./figures/PCIe_4Lane_split4_USB_SATA.png" alt="" />&lt;figcaption>PCIe_4Lane_split4_USB_SATA&lt;/figcaption>
&lt;/figure>
&lt;p>那么回过头来，看第一种情况，我们也可以不接 controller 2 和 controller 3&lt;/p>
&lt;figure>
&lt;img src="./figures/PCIe_4Lane_USB_SATA.png" alt="" />&lt;figcaption>PCIe_4Lane_USB_SATA&lt;/figcaption>
&lt;/figure>
&lt;p>所以这个事情就变得非常灵活了。那再来一张相对完整的图片（没有包含使用组合的限制）&lt;/p>
&lt;figure>
&lt;img src="./figures/PCIe_full_connection_info.drawio.png" alt="" />&lt;figcaption>PCIe_full_connection_info.drawio&lt;/figcaption>
&lt;/figure>
&lt;h2 id="dts">DTS&lt;/h2>
&lt;p>上面是硬件上的连接，那么软件上也就是设备树上怎么和上面的关联呢？根据 RK 文档，我们可以看到两张表，这里做了简化和修改。&lt;/p>
&lt;h3 id="phy">PHY&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>PHY Chip Type&lt;/th>
&lt;th>dts alias&lt;/th>
&lt;th>dts point&lt;/th>
&lt;th>Usage&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>PCIE3.0&lt;/td>
&lt;td>&lt;code>pcie30phy&lt;/code>&lt;/td>
&lt;td>&lt;code>phy@fee80000&lt;/code>&lt;/td>
&lt;td>pcie专⽤&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>PCIE2.0&lt;/td>
&lt;td>&lt;code>combphy0_ps&lt;/code>&lt;/td>
&lt;td>&lt;code>phy@fee00000&lt;/code>&lt;/td>
&lt;td>与SATA combo&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>PCIE2.0&lt;/td>
&lt;td>&lt;code>combphy1_ps&lt;/code>&lt;/td>
&lt;td>&lt;code>phy@fee10000&lt;/code>&lt;/td>
&lt;td>与SATA combo&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>PCIE2.0&lt;/td>
&lt;td>&lt;code>combphy2_psu&lt;/code>&lt;/td>
&lt;td>&lt;code>phy@fee20000&lt;/code>&lt;/td>
&lt;td>SATA/USB3 combo&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>comboPHY 就是 PCIE 信号线路和其他信号线路复用的 PHY，当然在使用的时候只能选择一种使用，由硬件设计。&lt;/p>
&lt;p>comboPHY dts alias name rule:&lt;/p>
&lt;ul>
&lt;li>如果和其他信号复用(mux)，phy 的 alias 名字以 combphy 来表示&lt;/li>
&lt;li>combphy 的后缀表⽰复⽤关系，p、s、u、q分别表⽰PCIe、SATA、USB、QSGMII&lt;/li>
&lt;/ul>
&lt;h3 id="controller">Controller&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>Controller index&lt;/th>
&lt;th>dts alias&lt;/th>
&lt;th>dts point&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>0&lt;/td>
&lt;td>&lt;code>pcie3x4&lt;/code>&lt;/td>
&lt;td>&lt;code>pcie@fe150000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>1&lt;/td>
&lt;td>&lt;code>pcie3x2&lt;/code>&lt;/td>
&lt;td>&lt;code>pcie@fe160000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>2&lt;/td>
&lt;td>&lt;code>pcie2x1l0&lt;/code>&lt;/td>
&lt;td>&lt;code>pcie@fe170000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>3&lt;/td>
&lt;td>&lt;code>pcie2x1l1&lt;/code>&lt;/td>
&lt;td>&lt;code>pcie@fe180000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>4&lt;/td>
&lt;td>&lt;code>pcie2x1l2&lt;/code>&lt;/td>
&lt;td>&lt;code>pcie@fe190000&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>dts alias rule:&lt;/p>
&lt;ul>
&lt;li>&lt;code>pcie2&lt;/code> PCIE 类型&lt;/li>
&lt;li>&lt;code>x1&lt;/code> 这个控制器最多能控制的 lane 数&lt;/li>
&lt;li>&lt;code>l0&lt;/code> lane index 0&lt;/li>
&lt;/ul>
&lt;p>关于更详细的配置，目前我并没有细看，因为看明白这点之后，和硬件的同事对了一下，发现一开始说的关于 &lt;code>fe160000&lt;/code> 的报错问题是因为我们现在的板子相较于那版，少接了一个 3142 芯片，少了两个 USB 口，而这条 Lane 对应的就是 &lt;code>fe160000&lt;/code>，目前它是空着的。&lt;/p>
&lt;h2 id="references">References:&lt;/h2>
&lt;ul>
&lt;li>[1] Rockchip_Developer_Guide_PCIe_CN.pdf&lt;/li>
&lt;li>[2] Rockchip_Developer_Guide_PCIe_CN.pdf&lt;/li>
&lt;/ul>
&lt;h2 id="resources">Resources:&lt;/h2>
&lt;p>本文图片源文件: &lt;a href="./res/rk3588_PCIe_intro.drawio">rk3588_PCIe_intro.drawio&lt;/a>&lt;/p>
&lt;h2 id="ps">ps&lt;/h2>
&lt;p>本文中摘录了部分 RK 文档中的内容，此部份内容均以 Reference 的形式指向 &lt;code>Rockchip_Developer_Guide_PCIe_CN.pdf&lt;/code>。私以为并未“超越合理使用范畴”，如 Rockchip 认为“超越合理使用范畴”请联系告知，我将会移除此部份。&lt;/p>
&lt;p>RK 文档中的版权声明：&lt;/p>
&lt;blockquote>
&lt;p>版权所有 © 2023 瑞芯微电子股份有限公司&lt;/p>
&lt;p>超越合理使用范畴，非经本公司书面许可，任何单位和个人不得擅自摘抄、复制本文档内容的部分或全部，并不得以任何形式传播。&lt;/p>
&lt;/blockquote></description></item><item><title>about rk3588 disk partitions(未完待续) and fdisk, dd</title><link>https://bensyz.github.io/blog/blogs/about_rk3588_disk_partitions_and_fdisk_dd/</link><pubDate>Wed, 16 Aug 2023 09:28:51 +0800</pubDate><guid>https://bensyz.github.io/blog/blogs/about_rk3588_disk_partitions_and_fdisk_dd/</guid><description>&lt;p>推荐文档：&lt;/p>
&lt;p>&lt;code>Rockchip_Developer_Guide_UBoot_Nextdev_CN.pdf&lt;/code>&lt;/p>
&lt;p>以前在 Windows 上 用 &lt;code>RKDevTool_Release.exe&lt;/code> 烧录镜像时一直有个疑惑： &lt;code>miniloader&lt;/code> 和 &lt;code>parameter&lt;/code> 的地址为什么是 &lt;code>0x0&lt;/code>，好像是烧到其他地方去了，并且 &lt;code>lsblk&lt;/code> 也看不到这两个文件所在的分区。&lt;/p>
&lt;figure>
&lt;img src="./figures/rk_burn_window.png" alt="" />&lt;figcaption>rk_burn_window&lt;/figcaption>
&lt;/figure>
&lt;pre class="console">&lt;code>$ lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
mmcblk0 179:0 0 14.6G 0 disk
├─mmcblk0p1 179:1 0 4M 0 part
├─mmcblk0p2 179:2 0 4M 0 part
├─mmcblk0p3 179:3 0 64M 0 part
├─mmcblk0p4 179:4 0 128M 0 part
├─mmcblk0p5 179:5 0 32M 0 part
├─mmcblk0p6 179:6 0 14G 0 part /
├─mmcblk0p7 179:7 0 128M 0 part /oem
└─mmcblk0p8 179:8 0 206M 0 part /userdata
mmcblk0boot0 179:32 0 4M 1 disk
mmcblk0boot1 179:64 0 4M 1 disk&lt;/code>&lt;/pre>
&lt;p>这两天在看 uboot 的文档时，&lt;code>Rockchip_Developer_Guide_UBoot_Nextdev_CN.pdf&lt;/code> 看到 &lt;code>2.6 存储布局&lt;/code> 这个疑惑接被解决了。&lt;/p>
&lt;figure>
&lt;img src="./figures/partition_tables.png" alt="" />&lt;figcaption>&lt;a href="https://opensource.rock-chips.com/wiki_Partitions">partition_tables&lt;/a>&lt;/figcaption>
&lt;/figure>
&lt;p>原来 minloader 被烧录到 mmcblk0p1 前的分区了，parameter.txt 本身就是分区表，应该就是生成了 GPT 分区表。&lt;/p>
&lt;h2 id="验证">验证&lt;/h2>
&lt;h3 id="fdisk">&lt;code>fdisk&lt;/code>&lt;/h3>
&lt;p>来验证一下&lt;/p>
&lt;pre class="console">&lt;code># fdisk -l /dev/mmcblk0
Disk /dev/mmcblk0: 14.56 GiB, 15634268160 bytes, 30535680 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 17B18C43-1D24-4484-8883-D0C618E42411
Device Start End Sectors Size Type
/dev/mmcblk0p1 16384 24575 8192 4M unknown
/dev/mmcblk0p2 24576 32767 8192 4M unknown
/dev/mmcblk0p3 32768 163839 131072 64M unknown
/dev/mmcblk0p4 163840 425983 262144 128M unknown
/dev/mmcblk0p5 425984 491519 65536 32M unknown
/dev/mmcblk0p6 491520 29851647 29360128 14G unknown
/dev/mmcblk0p7 29851648 30113791 262144 128M unknown
/dev/mmcblk0p8 30113792 30535646 421855 206M unknown&lt;/code>&lt;/pre>
&lt;p>&lt;code>fdisk&lt;/code> 的输出很清晰，前三个分区和上图中的加粗项一一对应。之前没主意到的是第一个分区并不是从 &lt;code>2048&lt;/code> 开始的。&lt;/p>
&lt;h3 id="dd">&lt;code>dd&lt;/code>&lt;/h3>
&lt;p>在用 &lt;code>dd&lt;/code> 验证之前，需要了解一下 &lt;code>fdisk&lt;/code> 的输出：&lt;/p>
&lt;p>&lt;code>mmcblk0&lt;/code> 一个 sector 的大小是 512 bytes，第一个分区起始 sector 是 16384，占用 &lt;code>24575 - 16383 = 8192&lt;/code> 个 sector，这里减去 16383 是因为 16384 这个编号的 sector 是第一个分区的第一个 sector，长度是减去不属于第一个分区的最后一个 sector 的编号。再看上面那张图片，整个磁盘的起始 sector 的编号是 0，MBR 占用 1 个 sector；同时，第一个分区前的 sector 的数量是第一个分区的编号。这里说得这么啰嗦是因为后面 &lt;code>dd&lt;/code> 需要这些参数。再回过头来看第一个分区，第一个分区的大小是 &lt;code>8192 * 512 B = 8K * 512 B = 4 MB&lt;/code>。再看磁盘最后的位置：最后一个分区后还有 &lt;code>30535679 - 30535646 = 33&lt;/code> 个分区，也就是 secondary gpt 分区。这里是用 30535679 减，是因为 Disk 那一行中的 30535680 是指长度，由于我们是从 0 开始编号的，所以最后一个分区的编号是 30535679。&lt;/p>
&lt;figure>
&lt;img src="./figures/disk_and_part.png" alt="" />&lt;figcaption>disk_and_part&lt;/figcaption>
&lt;/figure>
&lt;ol type="1">
&lt;li>使用 dd 获取第一个分区：&lt;/li>
&lt;/ol>
&lt;p>因为第一个分区被分区了，所以我们可以直接设定 &lt;code>if&lt;/code> 为分区&lt;/p>
&lt;div class="sourceCode" id="cb3">&lt;pre class="sourceCode sh">&lt;code class="sourceCode bash">&lt;span id="cb3-1">&lt;a href="#cb3-1" aria-hidden="true">&lt;/a>&lt;span class="fu">dd&lt;/span> if=/dev/mmcblk0p1 of=./uboot.img bs=512&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>由于我们最终是想读取第一个分区前的数据，所以我们这里通过第一个分区来验证和练习一下：&lt;/p>
&lt;pre class="console">&lt;code># dd if=/dev/mmcblk0 bs=512 skip=16384 count=8192 | sha1sum
68b4104cad133f08b54a88161fc0ac8c9fdf2a81 -&lt;/code>&lt;/pre>
&lt;p>同时我们校验一下通过分区读出来的镜像 hex，发现也是一样&lt;/p>
&lt;pre class="console">&lt;code># sha1sum uboot.img
68b4104cad133f08b54a88161fc0ac8c9fdf2a81 uboot.img&lt;/code>&lt;/pre>
&lt;p>由此，我们可以得出以下结论：&lt;/p>
&lt;p>&lt;code>dd&lt;/code> 中 SKIP 的大小 = 需要忽略的 sector 数量 (count) = 想读区域的起始编号（start index），起始编号也就是 fdisk 中的 Start 列。&lt;/p>
&lt;ol start="2" type="1">
&lt;li>使用 dd 获取 miniloader ：&lt;/li>
&lt;/ol>
&lt;div class="sourceCode" id="cb6">&lt;pre class="sourceCode sh">&lt;code class="sourceCode bash">&lt;span id="cb6-1">&lt;a href="#cb6-1" aria-hidden="true">&lt;/a>&lt;span class="fu">dd&lt;/span> if=/dev/mmcblk0 of=./miniloader.img bs=512 skip=64 count=7104&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>呃，有重复部分，但是不是完全一样，需要看一下这两者的区别。（TODO）&lt;/p></description></item></channel></rss>